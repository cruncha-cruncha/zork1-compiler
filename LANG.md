# Zil-Like Language Specification

Zil-like is obviously inspired by [zil](https://en.wikipedia.org/wiki/Zork), but is different. Can read the files in `./output-files` as example code.

## Testing

1. Put all zil code in the ./input-files directory. All files in here will be parsed as if they're zil code. Naming convention does not matter
2. Execute `cargo run` from the root of this project
3. Serve http files from the ./output-files directory

## Concepts

A game consists of:

- a player
- some commands
- rooms the player can navigate through
- objects the player can interact with

In this document, 'player' always refers to the code construct, whereas 'user' refers to the actual human being piloting the player around.

The player, all rooms, and all objects can have:

- a description
- variables
- nested objects

The player is located in a room, aka C-ROOM (the current room). All object instances have a location, which can be a room, the player, or another object instance (aka is nested).

All objects have a prototypical definition, but the player can only interact with object instances. This lets the developer write one definition for 'chair', but create as many copies as they like. All copies share the same description (the description is defined at the prototype level). The prototype defines default variables, but each copy has it's own set. Each copy has it's own location, and own nested object instances.

All variables in the player, a room, or an object must be an integer. There is no error handling or null values, so variables which don't exist have a value of zero (zero is returned when getting the value of a variable which doesn't exist).

The player can attempt to move from room to room by entering a `GO <direction>` command, where `<direction>` is one of the words defined by the special top-level keyword `DIRECTIONS`.

Commands are defined using the `SYNTAX` keyword, and cannot contain any punctuation. The first word of a command is called the 'action', and should generally be unique. The action specifies what code to run in respone to a valid command.

## Pipeline

The details of this are not important right now, but it may be useful for later reference.

1. The user enters some text
2. The text gets passed to the engine function `handleRawInput`
3. this calls `parseInput` (aka the parser, defined in `./output-files/parser.js`, generated by the compiler)
   - if the parser can't handle it, exit the engine
   - if it's a `GO` command, call `handleGo`
   - if it's another command, handle it by calling some generated code
4. always return some info out of the engine

# Top-Level Keywords

These can only be defined at the top-level of a zil file (aka cannot be called from within a routine or handler): they statically define the parameters of a game. Any code surrounded by angle brackets (`< ... >`) is called a 'cluster', any code surrounded by parenthesis (`( ... )`) is called a 'group'. If there was a top-level keyword `APPLE`, it would be written in the code like `<APPLE ... >`: it could be called an 'apple cluster'. The code `<APPLE (WORMS 2)>` could be described as: 'an apple cluster with two children: first child is the word APPLE, second child is a worms group'.

Comments are any cluster, group, or text prepended with a semicolon. The cluster or group must be somewhat valid (can't contain lowercase letters, for instance).

```
;"this is a comment"
;(THIS IS ALSO A COMMENT)
; "this is not"
```

## `PLAYER`

This cluster defines the player character. Every child (after the first) must be a group. Possible groups are: `DESC`, `ROOM`, and `VARS`. Valid description groups might look like:

```
(DESC "a travel with long, tangled hair")
(DESC "a stout animal" CR)
(DESC <DESC-PLAYER>)
```

The last example assumes the existence (definition exists) of a routine called `DESC-PLAYER`. The word `CR` can optionally be added after text in a description group, to represent a newline. A valid room group might look like:

```
(ROOM HIGH-PLAINS)
(ROOM CABIN-INTERIOR)
```

Assuming those rooms exist (are defined). A variable group holds any number of key-value pairs. Valid variable groups might look like:

```
(VARS HEALTH 40 STRENGTH 12)
(VARS DEAD 0 HAS-BINGO 1 IS-BONGO 1 CAN-BANGO 1)
```

If player vars were defined given the first example, player would have a `HEALTH` variable equal to the integer value 40, and a `STRENGTH` variable equal to the integer value 12. The only reason for defining a variable with a value of zero (such as `DEAD` in the second example) is for comprehension; the code will run fine without it, as reading a variable which doesn't exist will return zero, and writing to a variable that doesn't exist will create it (if writing to the player, a room, or an object instance).

Multiple examples have been provided for illustrative purposes, but in general only one group of any given type can be defined per cluster: a player cannot have two different descriptions.

## `ROOM`

All children (after the first and second) must be a group. The second child is the name of the room, and it must be unique. For example, `<ROOM GARAGE-1 ... >`.

Can define a `DESC` and `VARS` group for each room. Can also define all possible directions of travel out of this room.

### `DIRECTIONS`

Directions is a special top-level keyword that should only be defined once. For example:

```
<DIRECTIONS UP DOWN>
```

This means that the user can enter commands `GO UP` and `GO DOWN`, but not `GO LEFT` nor any other command starting with `GO` (they can enter these commands of course, the commands just won't do anything).

Back to `ROOM`, any room can define one group per direction. For example:

```
(NORTH "You can't go that way")
(EAST TO KITCHEN)
(SOUTH PER <BEDROOM-1-SOUTH>)
```

The first example has some text: that text will always be shown (logged) if the player tries to `GO NORTH` while in this room. As a consequence, the player can never travel north from this room (at least not using the `GO` command). Note that a `CR` after the text (as in a `DESC` group) is always implied and never allowed explicitly.

The second example specifies another room to go to: `KITCHEN`. If the player enters command `GO KITCHEN` while in this room, the engine will attempt to move the player to the kitchen. As with the first example, this cannot change at game-time.

The third example indicates that the routine `BEDROOM-1-SOUTH` should be run when the player enters command `GO SOUTH`. This routine can do anything at all; it may or may not move the player. It may move the player to the `ELEVATOR` in some cases, or the `STAIRCASE` in others. This allows the game map to change at game-time.

In the demo game, a routine named `BEDROOM-1-SOUTH` probably means that the current room is called `BEDROOM-1` and the player is trying to go south, but this convention can be broken freely.

There is no `WEST` group in the example: rooms are free to define as few direction groups as they wish. A room with no direction groups cannot be escaped from using the `GO` command.

## `OBJECT`

Like room, all children (after the first and second) must be a group. The second child is the name of the object, and must be unique. For example: `<OBJECT BICYCLE ... >`. Only one 'instance' of a room can exist, so they are ofter prepended with '-1', '-2', '-3', etc. Any number of copies ('instances') of an object can exist, so prepending a number is not always necessary.

Like player and room, can define a `DESC` and `VARS` group. Can also define an `AKA` group and a `COPY` group. Let's look at some examples for `AKA` first:

```
<OBJECT AXE
    (AKA AXE AX)>

<OBJECT ROUGH-BOARDS
    (AKA BOARD BOARDS ROUGH-BOARD ROUGH-BOARDS)>
```

`AKA` defines words that can be used in a syntax for refering to this object. The second child (`AXE` or `ROUGH-BOARDS` above) is used internally (by the zil-like source code) to unambiguously refer to an object. But the user might forget to always enter `AXE` with an E, so `AX` will be treated the same way for convenience. `AKA` is kind of like defining synonyms for an object, but it also defines the root word: the user can never refer to an object if it doesn't have an `AKA` group. Below is entirely valid but not advised.

```
<OBJECT RED-BOOK
    (AKA BLUE-TV)>
```

It's good practice to always define an `AKA` group, and include the object name (second child) in it. If the user can never ever ever interact with an object, it's ok to omit.

Let's move on to the `COPY` group now. Earlier, in the 'Concepts' section, it was mentioned that the player can interact with object instances but not a prototypical object. The top-level object keyword defines a prototypical object, and `COPY` group defines instances that are present at the start of the game. For example:

```
<OBJECT FLOUR
    (COPY <ROOM KITCHEN-1>
          <ROOM KITCHEN-2 (VARS AMOUNT 5)>
          <ROOM KITCHEN-3 (VARS MOLDY 1)>
          <BAG 2>)
    (VARS AMOUNT 10)>

<OBJECT BAG
    (COPY <ROOM SMALL-GROCER>
          <ROOM LARGE-GROCER)>
```

At the start of the game, an instance of the flour object will exist in some rooms with variables:

- `KITCHEN-1`: AMOUNT = 10 (the default variable)
- `KITCHEN-2`: AMOUNT = 5 (overrides the default variable value)
- `KITCHEN-3`: AMOUNT = 10, MOLDY = 1 (the default variable and a custom variable)

Hopefully this illustrates how copies inherit and override default variables from the prototypical object. The last copy of flour is nested inside the second instance of the `BAG` object: it winds up inside a `BAG`, inside the room `LARGE-GROCER`. There is no `<BAG 0>` (indexing starts at 1).

Instances can be created, destroyed, and nested at game-time. Default object variables cannot be changed at game-time.

## `GLOBAL`

Aka a global (integer-only) variable. New global variables cannot be created at game-time (unlike variable in the player, an object instance, or a room). Can define any number of global variables, but each must have a unique name. For example:

```
<GLOBAL HOUR 3>
<GLOBAL MINUTE 48>
<GLOBAL DAY 2>
<GLOBAL FIRST-GLANCE 1>
```

The first child must be `GLOBAL`, the second child must be a word, and the third child must be a number.

## `SYNTAX`

Syntax defines an input command the user can enter. It could look like:

```
<SYNTAX RUN AWAY>
<SYNTAX AM I GOING TO CRASH>
<SYNTAX WEATHER REPORT>
<SYNTAX EAT NEAREST OBJECT>
```

### `BUZZ`

When the user enters some text, it's passed as a string to the parser. The parser splits this string on whitespace, then looks at each word individually, starting from the first word. If some words can be ignored, `BUZZ` them: they will be completely removed after splitting the string. In the demo game, buzz is defined as:

```
<BUZZ A OF MY ALL SOME THE AGAIN>
```

So if the user enters the command `TAKE ALL OF THE APPLES`, it'll be split then buzzed into the array [`TAKE`, `APPLES`]. `BUZZ` is not applied to syntax, so `<SYNTAX TAKE THE OBJECT>` will never be matched.

If `BUZZ` is defined multiple times, it's treated as if there is only one definition, with a set of all words built from combining all the different definitions. It's easiest just to define it once.

### `SYNONYM`

In order to provide flexibility to the user, synonyms can be defined for any word. The synonyms apply to that word in any syntax.

```
<SYNTAX WALK FAST>
<SYNONYMS WALK RUN AMBLE STRIDE>
<SYNONYMS FAST FASTER>
<SYNTAX HOW FAST AM I GOING>
```

Assuming that no words are buzzed, the above definitions match the following commands:

- `WALK FAST`
- `RUN FAST`
- `AMBLE FAST`
- `STRIDE FAST`
- `WALK FASTER`
- `RUN FASTER`
- `AMBLE FASTER`
- `STRIDE FASTER`
- `HOW FAST AM I GOING`
- `HOW FASTER AM I GOING`

The order of syntax and synonym definitions don't matter: the second child in a synonym (like `FAST`) is applied to all instances of that word in all syntaxes. We end up matching `HOW FASTER AM I GOING` which doesn't make a lot of sense, but should actually be ok: it doesn't have to make sense grammatically (because the user will never see it) as long as it makes sense programatically.

Commands can quickly become unwieldy between `SYNTAX`, `BUZZ`, and `SYNONYM`, but let's get back to `SYNTAX` for now.

The second child of a syntax (`RUN`, `AM`, `WEATHER`, `GRAB`) is called the 'action'. If two or more syntaxes have the same action (start with the same word), they will execute the same action handler (some of the same code will run in response to the commands). This strict limitation (hopefully) keeps the number of possible commands small and action-oriented. In the demo game, the below two syntaxes are treated (for better or worse) the same.

```
<SYNTAX WHERE AM I>
<SYNTAX WHERE CAN I GO>
```

Because they both start with the same action `WHERE`. A valid command will run (fire/execute) it's corresponding action and object handlers. Handlers are similar to routines (next section). To define an action handler, write a top-level cluster starting with the action word. For example:

```
<WHERE ()
    <TELL "You're guess is as good as mine">
>
```

This is an action handler for any command that starts with `WHERE` (aka any syntax who's second child is `WHERE`). Every time the user enters the command `WHERE AM I`, this action handler will run, which will tell (aka log) some text. The same thing happens every time the user enters the command `WHERE CAN I GO`, because it has the same action (`WHERE`).

Note that actions are always translated into their root form (synonym-wise) before coming out of the parser. So from the example earlier:

```
<SYNTAX WALK FAST>
<SYNONYMS WALK RUN AMBLE STRIDE>
```

If the user enters command `RUN FAST`, the action coming out the parser would be `WALK`. This means that every syntax has at most one action handler, not an action handler for every synonym.

What about object handlers? Earlier, we saw this example:

```
<SYNTAX EAT NEAREST OBJECT>
```

`OBJECT` has special meaning in a syntax. It will match any object in the player or current room (nested at any depth), based on the object's `AKA` (see earlier). So if there's candy in the current room, and the user enters command `EAT NEAREST CANDY`, this syntax will match. If there's no candy in the room or in the player, the syntax will not match, and the action handler won't execute. It's possible to not define an action handler and still execute code if the command matches, by using an object handler.

```
<EAT CANDY ()
    <TELL "It's yummy">
>
```

This object handler will execute if all of the following is true:

- there is a syntax that starts with `EAT`
- the syntax has at least one `OBJECT`
- any `OBJECT` in the syntax is in the same place as `CANDY` in the user's command. It could be the first `OBJECT`, could be the fifth `OBJECT`, doesn't matter
- an instance of an object with `CANDY` in it's `AKA` exists in the player or current room (at any level of nesting)

Maybe `EAT` doesn't have an action handler, and instead this command is handled exclusively by object handlers. Eating some objects will make the player sick. Others will give them health. Others will do nothing.

If `EAT` does have an action handler, the `EAT CANDY ()` object handler will execute before the action handler. The `EAT () CANDY` object handler will execute after the action handler: the position of the parenthesis dictates whether an object handler is executed before or after the action handler.

Each syntax can have one action handler, and two object handlers (one before and one after) for every object, if the syntax has at least one `OBJECT`. So if there are 20 objects in the game, and a `<SYNTAX KICK OBJECT AT OBJECT USING OBJECT>`, there is potentially one action handler and 40 object handlers.

## `ROUTINE`

Handlers are just routines with special triggers. Let's look at an example of a routine:

```
<ROUTINE SET-PLAYER-ON-FIRE ()
    <SET-VAR PLAYER BURNING 1>
    <TELL "You're on fire!">
>
```

This defines a routine called `SET-PLAYER-ON-FIRE`. Routines can only be defined at the top-level. This routine assigns the value 1 to a variable called `BURNING` in the player, then tells the user (logs out) that they're on fire. Every child of a routine (after the first three) must be a cluster.

Variables cannot be passed into a routine. The parenthesis (third child) is used to define variables that are local to a routine. So we could write:

```
<ROUTINE BURN-PLAYER (DMG)
    <SET-VAR DMG <RAND>>                           ;"set the local variable DMG to a random number"
    <SET-VAR PLAYER BURNING DMG>                   ;"assign the value of DMG to the player's BURNING variable"
    <TELL "You've been burned for " DMG " points"> ;"log out how much burning the player has taken"
>
```

`PLAYER` and `C-ROOM` (current room) is always accessible to every handler and routine, as well as the syntax `CMDS` (aka object instances from the parsed syntax, explained more in the the next section).

# Handlers and Routines

There are 25 clusters available to use as building blocks inside a routine (or handler). They use [polish notation](https://en.wikipedia.org/wiki/Polish_notation), for example:

```
<SUBTRACT <MULTIPLY 2 3> <ADD 9 1>>
```

Resolves to `(2 x 3) - (9 + 1)`.

Many clusters accept arguments of a certain type, the types are:

- INST: an object instance
- ROOM: the name of a room
- PLAYER: the player
- IRP: an object Instance, a Room, or the Player
- OBJ: the name of an object (the prototypical object)
- VAR: the name of a variable, either existing or new
- TEXT: anything enclosed in double quotes
- NUM: an integer
- BOOL: a boolean

A boolean cannot be expressed literally, it only shows up as the return value of a cluster: there is no explicit 'true' or 'false' in the code. A (local or global) variable, or any routine, that returns type T is equivalent to type T and can be used in it's place as an argument to a cluster.

Any handler or routine returns a NUM, zero if no explicit `RETURN` is called.

```
;"various"
<RAND>             ;"returns a random integer from 0 to 99 (inclusive)"
<RETURN NUM>       ;"exit handler/routine, returns nothing, but sets the return value of the handler/routine"
<TELL TEXT/NUM>    ;"any number of TEXT/NUM args, returns nothing"
<TELL TEXT/NUM CR> ;"any number of TEXT/NUM args, followed by CR (newline), return nothing"
<DESC IRP>         ;"describe the IRP (see DESC group), returns nothing"
<CMD NUM>          ;"get the NUMth object instance matching this syntax/command, starts from 1"
;"<CMD 1> would return a specific instance of the CANDY object if called while handling EAT NEAREST CANDY"

;"get/set variables"
;"there is no GET-VAR VAR: just use VAR directly instead"
<GET-VAR IRP VAR>     ;"returns a NUM, zero if the variable doesn't exist"
<SET-VAR VAR NUM>     ;"set a local or global variable, no return value"
<SET-VAR IRP VAR NUM> ;"no return value"

;"math, all return a NUM"
<ADD NUM NUM NUM>      ;"as many NUMS as you want"
<SUBTRACT NUM NUM>     ;"exactly two NUMS"
<MULTIPLY NUM NUM NUM> ;"as many NUMS as you want"
<DIVIDE NUM NUM>       ;"exactly two NUMS"

;"conditionals, all return a BOOL"
<IS-DES NUM NUM NUM>      ;"any number of NUMs, returns true if they're all in descending order (3,2,1), otherwise false"
<IS-ASC NUM NUM NUM>      ;"any number of NUMs, returns true if they're all in ascending order (1,2,3), otherwise false"
<IS-EQUAL INST INST INST> ;"any number of args (regardless of type), returns true if all the same instance"
<IS-EQUAL INST INST OBJ>  ;"if one or more OBJ and one or more INST, returns true if all INSTs are copies of OBJ, and all OBJs are the same"
<IS-EQUAL OBJ OBJ>        ;"returns true if all the same OBJ"
<IS-EQUAL NUM NUM>        ;"returns true if all the same number"
<IS-EQUAL TEXT TEXT>      ;"returns true if all the same text"
;"mixing and matching types in IS-EQUAL will just return false"
<IS-IN IRP IRP/OBJ>       ;"IRP is in IRP, or an instance of OBJ is in IRP, not nested. returns true if IRP == IRP"
<IS-IN IRP IRP/OBJ N>     ;"same as above, but allow nesting. returns false if IRP == IRP"

;"logic, all return a BOOL"
<AND BOOL BOOL BOOL> ;"at least two BOOLs, they must all be true"
<OR BOOL BOOL BOOL>  ;"at least two BOOLs, at least one must be true"
<NOT BOOL>           ;"one BOOL, returns the opposite"

;"objects"
<LOC INST>       ;"return the IRP which contains INST"
<LOC INST N>     ;"return the containing room of INST"
<INST IRP OBJ>   ;"return the first instance of OBJ in IRP, cannot be nested. Returns an empty object if none found"
<INST IRP OBJ N> ;"return the first instance (breadth-first) of OBJ in IRP, can be nested. Returns an empty object if none found"
;"Empty objects have no variables, no container, no description, and no nested objects"
;"Empty objects are equal to eachother but nothing else"


;"move stuff, all return a BOOL"
<MOVE INST>          ;"delete INST, returns true if valid INST"
<MOVE INST IRP>      ;"move INST from wherever it was to IRP, does nothing if it was already there"
<MOVE PLAYER ROOM>   ;"move the player to a room, does nothing if they're already there"
<COPY-MOVE OBJ IRP>  ;"create a new instance of OBJ, with default variables, in IRP. Does not copy nested object instances"
<COPY-MOVE INST IRP> ;"copy INST (making a new instance) to IRP. Does not copy nested object instances"

;"control flow, all return nothing, ... = any clusters"
<COND (BOOL ...) (BOOL ...)>    ;"at least one groups, executes the first one where BOOL is true"
<EACH-OBJ IRP (VAR) ... >       ;"loops through each instance of any object in IRP, does not include nested"
<EACH-OBJ OBJ (VAR) ... >       ;"loops through each instance of OBJ, regardless of it's location"
<EACH-VAL IRP (VAR1 VAR2) ... > ;"loops through each variable in IRP, VAR1 gets the variable name (is type TEXT), VAR2 gets the variable value"
<EACH-VAL NUM (VAR) ... >       ;"loops from zero up to (but not including) NUM, setting VAR to value on each loop"
```

# Hooks

Hooks have been omitted thus far to avoid overwhelming the reader. Hooks add more interaction to the game, by firing (executing) routines in response to different events. Three hooks can be assigned to the player:

- ACT-ENTER: fires when the player enters any room
- ACT-EXIT: fires when the player exits any room
- ACT-ALWAYS: fires after every command

Zero, one, two, or all three of the hooks can be defined. Every room can be assigned any number of a similar set of three hooks:

- ACT-ENTER: fires when the player enters this room
- ACT-EXIT: fires when the player leaves this room
- ACT-ALWAYS: fires after every command while the player is in this room

A hook is defined by adding it as a group. For example, a `TRAP-1` room might be on fire, and we want to set the player on fire whenever they enter the room, using a routine called `SET-PLAYER-ON-FIRE`.

```

<ROOM TRAP-1
(ACT-ENTER <SET-PLAYER-ON-FIRE>)>

```

Every object can be assigned any number of four hooks:

- ACT-IN-ROOM: fires after every command while this object is in the same room as the player (fires even if the object is nested)
- ACT-IN-PLAYER: fires after every command while this object is in the player's inventory (fires even if the object is nested)
- ACT-ADD: fires when this object is added to the player's inventory
- ACT-REMOVE: fires when this object is removed from the player's inventory

## Firing order

Many hooks can be triggered during the course of a routine, but they don't fire immediately, and may not even fire at all (see last paragraph). All hooks are always fired after executing the syntax command and it's handlers (if any), see `getPriority` in `./js-boilerplate/hooks.js`.

- objects ACT-REMOVE
- objects ACT-ADD
- room ACT-EXIT
- player ACT-EXIT
- room ACT-ENTER
- player ACT-ENTER
- objects ACT-IN-ROOM
- objects ACT-IN-PLAYER
- room ACT-ALWAYS
- player ACT-ALWAYS

Object hooks generally fire for every object that was moved (including objects not explicitly moved by the player), and firing order is always respected. So if a theatre's (a room) ACT-ENTER hook removes a concert ticket (an object) from the players inventory, the concert ticket's ACT-REMOVE action will fire before the theatre's ACT-ALWAYS action.

When a hook is inserted, it removes all upcoming hook calls of lower priority. This an opaque process which can lead to unexpected behaviour, so always test your hooks. Details of exactly when hooks are inserted (and more importantly, called) can muddled out of `./js-boilerplate/engine.js`, see especially `// run all queued hooks to ensure...`.

# Illegal Names

The following names (for variables or routines) are illegal:

- `C-ROOM`
- `CMD`
- `PLAYER`
- `GO`
- `ROUTINE`
